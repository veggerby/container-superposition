import { describe, it, expect } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { composeDevContainer } from '../questionnaire/composer.js';
import type { QuestionnaireAnswers } from '../schema/types.js';

// Get __dirname equivalent in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const REPO_ROOT = path.join(__dirname, '..', '..');
const TEST_OUTPUT_DIR = path.join(REPO_ROOT, 'tmp', 'test-readme-generation');

describe('README Generation', () => {
    it('should generate README.md with basic structure', async () => {
        const outputPath = path.join(TEST_OUTPUT_DIR, 'test-basic-readme');

        // Clean up previous test output
        if (fs.existsSync(outputPath)) {
            fs.rmSync(outputPath, { recursive: true });
        }

        const answers: QuestionnaireAnswers = {
            stack: 'compose',
            baseImage: 'bookworm',
            containerName: 'Test Environment',
            language: ['nodejs'],
            needsDocker: false,
            database: ['postgres'],
            playwright: false,
            cloudTools: [],
            devTools: [],
            observability: [],
            outputPath,
        };

        await composeDevContainer(answers);

        // Verify README.md was created
        const readmePath = path.join(outputPath, 'README.md');
        expect(fs.existsSync(readmePath)).toBe(true);

        // Load and verify content
        const readme = fs.readFileSync(readmePath, 'utf-8');

        // Check for required sections
        expect(readme).toContain('# Test Environment');
        expect(readme).toContain('Generated by Container Superposition');
        expect(readme).toContain('Template: compose');
        expect(readme).toContain('## Quick Start');
        expect(readme).toContain('## Services and Tools');
        expect(readme).toContain('## References');

        // Check for overlay-specific content
        expect(readme).toContain('Node.js');
        expect(readme).toContain('PostgreSQL');

        // Clean up
        fs.rmSync(outputPath, { recursive: true });
    });

    it('should include connection information from overlay READMEs', async () => {
        const outputPath = path.join(TEST_OUTPUT_DIR, 'test-connection-info');

        if (fs.existsSync(outputPath)) {
            fs.rmSync(outputPath, { recursive: true });
        }

        const answers: QuestionnaireAnswers = {
            stack: 'compose',
            baseImage: 'bookworm',
            language: [],
            needsDocker: false,
            database: ['postgres', 'redis'],
            playwright: false,
            cloudTools: [],
            devTools: [],
            observability: [],
            outputPath,
        };

        await composeDevContainer(answers);

        const readmePath = path.join(outputPath, 'README.md');
        const readme = fs.readFileSync(readmePath, 'utf-8');

        // Check for PostgreSQL connection info
        expect(readme).toContain('PostgreSQL');
        expect(readme.toLowerCase()).toContain('connection');

        // Check for Redis connection info
        expect(readme).toContain('Redis');

        // Clean up
        fs.rmSync(outputPath, { recursive: true });
    });

    it('should handle multiple overlay categories', async () => {
        const outputPath = path.join(TEST_OUTPUT_DIR, 'test-multiple-categories');

        if (fs.existsSync(outputPath)) {
            fs.rmSync(outputPath, { recursive: true });
        }

        const answers: QuestionnaireAnswers = {
            stack: 'compose',
            baseImage: 'bookworm',
            containerName: 'Full Stack Environment',
            language: ['nodejs'],
            needsDocker: false,
            database: ['postgres'],
            playwright: false,
            cloudTools: ['aws-cli'],
            devTools: ['docker-sock'],
            observability: ['prometheus', 'grafana'],
            outputPath,
        };

        await composeDevContainer(answers);

        const readmePath = path.join(outputPath, 'README.md');
        const readme = fs.readFileSync(readmePath, 'utf-8');

        // Check for category headers
        expect(readme).toContain('Languages and Frameworks');
        expect(readme).toContain('Databases and Storage');
        expect(readme).toContain('Observability and Monitoring');
        expect(readme).toContain('Cloud and Infrastructure Tools');
        expect(readme).toContain('Development Tools');

        // Clean up
        fs.rmSync(outputPath, { recursive: true });
    });

    it('should include environment variables section when .env.example exists', async () => {
        const outputPath = path.join(TEST_OUTPUT_DIR, 'test-env-vars');

        if (fs.existsSync(outputPath)) {
            fs.rmSync(outputPath, { recursive: true });
        }

        const answers: QuestionnaireAnswers = {
            stack: 'compose',
            baseImage: 'bookworm',
            language: [],
            needsDocker: false,
            database: ['postgres'], // Has .env.example
            playwright: false,
            cloudTools: [],
            devTools: [],
            observability: [],
            outputPath,
        };

        await composeDevContainer(answers);

        const readmePath = path.join(outputPath, 'README.md');
        const readme = fs.readFileSync(readmePath, 'utf-8');

        // Check for environment variables section
        expect(readme).toContain('## Environment Variables');
        expect(readme).toContain('cp .env.example .env');

        // Clean up
        fs.rmSync(outputPath, { recursive: true });
    });

    it('should include references to overlay documentation', async () => {
        const outputPath = path.join(TEST_OUTPUT_DIR, 'test-references');

        if (fs.existsSync(outputPath)) {
            fs.rmSync(outputPath, { recursive: true });
        }

        const answers: QuestionnaireAnswers = {
            stack: 'compose',
            baseImage: 'bookworm',
            language: ['nodejs'],
            needsDocker: false,
            database: ['postgres'],
            playwright: false,
            cloudTools: [],
            devTools: [],
            observability: [],
            outputPath,
        };

        await composeDevContainer(answers);

        const readmePath = path.join(outputPath, 'README.md');
        const readme = fs.readFileSync(readmePath, 'utf-8');

        // Check for references section
        expect(readme).toContain('## References');
        expect(readme).toContain('nodejs');
        expect(readme).toContain('postgres');
        expect(readme).toContain('../overlays/');

        // Clean up
        fs.rmSync(outputPath, { recursive: true });
    });

    it('should work with plain template', async () => {
        const outputPath = path.join(TEST_OUTPUT_DIR, 'test-plain-template');

        if (fs.existsSync(outputPath)) {
            fs.rmSync(outputPath, { recursive: true });
        }

        const answers: QuestionnaireAnswers = {
            stack: 'plain',
            baseImage: 'bookworm',
            containerName: 'Simple Environment',
            language: ['nodejs'],
            needsDocker: false,
            database: [],
            playwright: false,
            cloudTools: [],
            devTools: [],
            observability: [],
            outputPath,
        };

        await composeDevContainer(answers);

        const readmePath = path.join(outputPath, 'README.md');
        expect(fs.existsSync(readmePath)).toBe(true);

        const readme = fs.readFileSync(readmePath, 'utf-8');
        expect(readme).toContain('# Simple Environment');
        expect(readme).toContain('Template: plain');

        // Clean up
        fs.rmSync(outputPath, { recursive: true });
    });

    it('should handle preset information in header', async () => {
        const outputPath = path.join(TEST_OUTPUT_DIR, 'test-preset-info');

        if (fs.existsSync(outputPath)) {
            fs.rmSync(outputPath, { recursive: true });
        }

        const answers: QuestionnaireAnswers = {
            stack: 'compose',
            baseImage: 'bookworm',
            containerName: 'Web API',
            preset: 'web-api',
            language: ['nodejs'],
            needsDocker: false,
            database: ['postgres', 'redis'],
            playwright: false,
            cloudTools: [],
            devTools: [],
            observability: ['prometheus', 'grafana'],
            outputPath,
        };

        await composeDevContainer(answers);

        const readmePath = path.join(outputPath, 'README.md');
        const readme = fs.readFileSync(readmePath, 'utf-8');

        // Check for preset in header
        expect(readme).toContain('Preset: web-api');

        // Clean up
        fs.rmSync(outputPath, { recursive: true });
    });
});
