/**
 * README generation for consolidated devcontainer documentation
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import type { QuestionnaireAnswers, OverlayMetadata } from '../schema/types.js';
import {
    parseMarkdown,
    findSection,
    extractSectionAsMarkdown,
    getFirstParagraph,
    type MarkdownSection,
} from './markdown-parser.js';

// Get __dirname equivalent in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Resolve REPO_ROOT that works in both source and compiled output
const REPO_ROOT_CANDIDATES = [
    path.join(__dirname, '..', '..'), // From source: tool/readme -> root
    path.join(__dirname, '..', '..', '..'), // From dist: dist/tool/readme -> root
];
const REPO_ROOT =
    REPO_ROOT_CANDIDATES.find(
        (candidate) =>
            fs.existsSync(path.join(candidate, 'templates')) &&
            fs.existsSync(path.join(candidate, 'overlays'))
    ) ?? REPO_ROOT_CANDIDATES[0];

const OVERLAYS_DIR = path.join(REPO_ROOT, 'overlays');

interface OverlayDocs {
    id: string;
    name: string;
    description: string;
    sections: Map<string, string>;
}

/**
 * Sections to extract from overlay READMEs
 * These are matched against H2 (##) level headings
 */
const SECTIONS_TO_EXTRACT = [
    /^connection\s+information$/i,
    /^common\s+commands$/i,
    /^configuration$/i,
    /^troubleshooting$/i,
    /^use\s+cases$/i,
];

/**
 * Extract section content with limited depth to avoid overly verbose output
 */
function extractSectionLimited(section: MarkdownSection, maxSubsections = 3): string {
    const parts: string[] = [];

    if (section.content) {
        parts.push(section.content);
    }

    // Only include first few subsections to keep README concise
    const subsectionsToInclude = section.subsections.slice(0, maxSubsections);
    
    for (const subsection of subsectionsToInclude) {
        if (parts.length > 0 && parts[parts.length - 1] !== '') {
            parts.push('');
        }
        parts.push(`**${subsection.title}**`);
        parts.push('');
        if (subsection.content) {
            // Limit content length - take first 500 characters
            const content = subsection.content;
            if (content.length > 500) {
                parts.push(content.substring(0, 500) + '...');
            } else {
                parts.push(content);
            }
        }
    }

    if (section.subsections.length > maxSubsections) {
        parts.push('');
        parts.push(`*... and ${section.subsections.length - maxSubsections} more items (see full documentation)*`);
    }

    return parts.join('\n').trim();
}

/**
 * Load and parse overlay README file
 */
function loadOverlayDocs(overlayId: string, metadata: OverlayMetadata): OverlayDocs | null {
    const readmePath = path.join(OVERLAYS_DIR, overlayId, 'README.md');

    if (!fs.existsSync(readmePath)) {
        return null;
    }

    const content = fs.readFileSync(readmePath, 'utf-8');
    const sections = parseMarkdown(content);

    // Extract relevant sections
    const extractedSections = new Map<string, string>();
    for (const pattern of SECTIONS_TO_EXTRACT) {
        const section = findSection(sections, pattern);
        if (section) {
            // Use limited extraction to keep README concise
            extractedSections.set(section.title, extractSectionLimited(section));
        }
    }

    // Get description from metadata or first paragraph
    let description = metadata.description || '';
    if (!description && sections.length > 0) {
        description = getFirstParagraph(sections[0].content);
    }

    return {
        id: overlayId,
        name: metadata.name || overlayId,
        description,
        sections: extractedSections,
    };
}

/**
 * Generate header section of README
 */
function generateHeader(answers: QuestionnaireAnswers): string {
    const parts: string[] = [];

    const title = answers.containerName || 'Development Environment';
    parts.push(`# ${title}`);
    parts.push('');
    parts.push(`> Generated by Container Superposition on ${new Date().toISOString().split('T')[0]}`);

    let metadata = `> Template: ${answers.stack}`;
    if (answers.baseImage && answers.baseImage !== 'bookworm') {
        metadata += ` | Base Image: ${answers.baseImage}`;
    }
    if (answers.preset) {
        metadata += ` | Preset: ${answers.preset}`;
    }
    parts.push(metadata);
    parts.push('');

    return parts.join('\n');
}

/**
 * Generate quick start section
 */
function generateQuickStart(answers: QuestionnaireAnswers): string {
    const parts: string[] = [];

    parts.push('## Quick Start');
    parts.push('');

    if (answers.stack === 'compose') {
        parts.push('This development environment uses Docker Compose to orchestrate multiple services.');
        parts.push('');
        parts.push('**Starting the environment:**');
        parts.push('');
        parts.push('1. Open this folder in VS Code');
        parts.push('2. When prompted, click "Reopen in Container"');
        parts.push('3. Wait for the container to build and services to start');
        parts.push('4. Your development environment is ready!');
    } else {
        parts.push('This development environment uses a single container image.');
        parts.push('');
        parts.push('**Starting the environment:**');
        parts.push('');
        parts.push('1. Open this folder in VS Code');
        parts.push('2. When prompted, click "Reopen in Container"');
        parts.push('3. Wait for the container to build');
        parts.push('4. Your development environment is ready!');
    }

    parts.push('');
    return parts.join('\n');
}

/**
 * Generate services section with extracted overlay documentation
 */
function generateServices(
    overlayDocs: OverlayDocs[],
    overlayMetadata: Map<string, OverlayMetadata>
): string {
    if (overlayDocs.length === 0) {
        return '';
    }

    const parts: string[] = [];
    parts.push('## Services and Tools');
    parts.push('');

    // Group overlays by category
    const categories: Record<string, OverlayDocs[]> = {};
    for (const docs of overlayDocs) {
        const metadata = overlayMetadata.get(docs.id);
        const category = metadata?.category || 'other';
        if (!categories[category]) {
            categories[category] = [];
        }
        categories[category].push(docs);
    }

    // Define category order
    const categoryOrder = ['language', 'database', 'observability', 'cloud', 'dev', 'other'];
    const categoryTitles: Record<string, string> = {
        language: 'Languages and Frameworks',
        database: 'Databases and Storage',
        observability: 'Observability and Monitoring',
        cloud: 'Cloud and Infrastructure Tools',
        dev: 'Development Tools',
        other: 'Other Services',
    };

    for (const category of categoryOrder) {
        const categoryDocs = categories[category];
        if (!categoryDocs || categoryDocs.length === 0) {
            continue;
        }

        // Only show category header if there are multiple categories
        if (Object.keys(categories).length > 1) {
            parts.push(`### ${categoryTitles[category] || category}`);
            parts.push('');
        }

        for (const docs of categoryDocs) {
            // Service name and description
            parts.push(`#### ${docs.name}`);
            parts.push('');
            if (docs.description) {
                parts.push(docs.description);
                parts.push('');
            }

            // Extract and include relevant sections
            for (const [sectionTitle, sectionContent] of docs.sections) {
                parts.push(`**${sectionTitle}**`);
                parts.push('');
                parts.push(sectionContent);
                parts.push('');
            }

            // Add link to full README
            parts.push(
                `*For complete documentation, see [${docs.name} overlay](../overlays/${docs.id}/README.md)*`
            );
            parts.push('');
        }
    }

    return parts.join('\n');
}

/**
 * Generate environment variables section (if .env.example exists)
 */
function generateEnvironmentVariables(outputPath: string): string {
    const envExamplePath = path.join(outputPath, '.env.example');

    if (!fs.existsSync(envExamplePath)) {
        return '';
    }

    const parts: string[] = [];
    parts.push('## Environment Variables');
    parts.push('');
    parts.push('This project uses environment variables for configuration. A template is provided:');
    parts.push('');
    parts.push('```bash');
    parts.push('cp .env.example .env');
    parts.push('```');
    parts.push('');
    parts.push('Then edit `.env` to customize for your environment.');
    parts.push('');
    parts.push('**Important:** The `.env` file is git-ignored and should not be committed.');
    parts.push('');

    return parts.join('\n');
}

/**
 * Generate troubleshooting section (aggregated from overlays)
 */
function generateTroubleshooting(overlayDocs: OverlayDocs[]): string {
    const troubleshootingDocs = overlayDocs
        .filter((docs) => docs.sections.has('Troubleshooting'))
        .map((docs) => ({ name: docs.name, content: docs.sections.get('Troubleshooting')! }));

    if (troubleshootingDocs.length === 0) {
        return '';
    }

    const parts: string[] = [];
    parts.push('## Troubleshooting');
    parts.push('');

    for (const { name, content } of troubleshootingDocs) {
        parts.push(`### ${name}`);
        parts.push('');
        parts.push(content);
        parts.push('');
    }

    return parts.join('\n');
}

/**
 * Generate references section
 */
function generateReferences(overlayIds: string[]): string {
    const parts: string[] = [];
    parts.push('## References');
    parts.push('');
    parts.push('**Overlay Documentation:**');
    parts.push('');

    for (const overlayId of overlayIds) {
        parts.push(`- [${overlayId}](../overlays/${overlayId}/README.md)`);
    }

    parts.push('');
    parts.push('**Project Documentation:**');
    parts.push('');
    parts.push('- [Container Superposition](../README.md)');
    parts.push('- [Documentation](../docs/README.md)');
    parts.push('');

    return parts.join('\n');
}

/**
 * Generate consolidated README.md from selected overlays
 */
export function generateReadme(
    answers: QuestionnaireAnswers,
    overlays: string[],
    overlayMetadata: Map<string, OverlayMetadata>,
    outputPath: string
): void {
    const parts: string[] = [];

    // 1. Header
    parts.push(generateHeader(answers));

    // 2. Quick Start
    parts.push(generateQuickStart(answers));

    // 3. Load overlay documentation
    const overlayDocs: OverlayDocs[] = [];
    for (const overlayId of overlays) {
        const metadata = overlayMetadata.get(overlayId);
        if (!metadata) {
            continue;
        }

        const docs = loadOverlayDocs(overlayId, metadata);
        if (docs && docs.sections.size > 0) {
            overlayDocs.push(docs);
        }
    }

    // 4. Services and Tools section
    if (overlayDocs.length > 0) {
        parts.push(generateServices(overlayDocs, overlayMetadata));
    }

    // 5. Environment Variables section
    const envSection = generateEnvironmentVariables(outputPath);
    if (envSection) {
        parts.push(envSection);
    }

    // 6. Troubleshooting section (aggregated)
    const troubleshooting = generateTroubleshooting(overlayDocs);
    if (troubleshooting) {
        parts.push(troubleshooting);
    }

    // 7. References
    parts.push(generateReferences(overlays));

    // Write README.md
    const readmePath = path.join(outputPath, 'README.md');
    const content = parts.join('\n').trim() + '\n';
    fs.writeFileSync(readmePath, content, 'utf-8');
}
